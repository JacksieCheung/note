## 初步了解 git

本文所有内容都出自[git-book](https://git-scm.com/book/zh/v2)，主要目的是了解git。

### 1. git 的本质

git是一个版本控制系统。

所谓版本控制，就是一种记录一个或若干文件**内容变化**，以便将来**查阅特定版本**修订情况的系统。

根据版本控制的定义，不难看出，git具有记录文件变化的功能（也就是备份），可以随时进行文件的回溯。

举个例子更好理解回溯功能的需求：A在开发一个软件，发布了非常稳定的版本1。然后有人给A提了issue，A立马就开始写，发布了版本2。结果他发现，版本2涉及到了一些问题，不能正常使用。（比如说侵权、以前版本中的重大bug等）

在上面这个例子中，版本2由于一些问题不能正常使用，A这个人可能会做的一件事情就是删掉版本2中比版本1多出来的代码。也就是**将整个项目回到版本1**。

那A具体要怎么做呢，手动删掉吗？那好像也删不干净。可能在写版本2的代码时，会和版本1的代码形成高度耦合，要改得花很多时间精力。

为了不出现手动改的麻烦，不难想到一个操作，就是在开发版本2前，手动复制代码。通过改名和标注时间等方式加以区分。这样做的唯一好处就是简单，但特别容易犯错，万一混淆了工作目录，一不小心覆盖了某个文件，就改不回来了。

因此针对将版本回溯的需求，版本控制系统应运而生。

### 1.1 git的前世今身

第一种开发的版本控制系统，叫做**本地版本控制系统**。它的原理是用简单的数据库来记录文件的历次更新差异。其中最流行的叫做RCS，它在硬盘上保存补丁集，通过应用所有补丁集，可以重新计算出各个版本的文件内容。

![图片](https://git-scm.com/book/en/v2/images/local.png)

>补丁的意思就是文件修改前后的变化，RCS记录的是文件之间的变化，也就是类似某一行删了，某一行改了，某一行加了这种变化。

其实有了本地版本控制系统，基本上就解决了我们前面讲到的版本回溯的需求。但版本控制系统的作用并没有止步于此。在开发项目中需要用到版本控制的，基本都有一个特点就是规模庞大。而大型项目往往需要多人协同开发。所以第二个需求便体现出来了：如何让不同系统的（或者远程的）开发者一起来开发同一个项目？这就有了第二个版本控制系统。

第二种开发的版本控制系统，叫做**集中化的版本控制系统**。这个版本控制系统有一个单一的集中管理服务器保存所有文件的修订版本。各用户只需要通过客户端连接到这台服务器，就能够取出最新的文件或者提交更新。

![图片](https://git-scm.com/book/en/v2/images/centralized.png)

上面是模型图。和本地版本控制系统的区别就是本地不再存储文件版本，而改为只有远程一个存储文件的服务器。不难理解集中化，指的就是多用户的版本集中化管理。本地的客户端，只是一个提交本地文件快照的工具。

>快照，指的是备份某一个时间点的文件。这个时间点的文件备份后，原文件可以改变，但备份出来的那部分文件就不再改变了。这个过程就像现实世界中给文件进行拍照，所以称为快照。

然而集中化版本控制系统并不稳定。如果中央服务器崩了，那么这个过程中谁都无法提交修改。于是，也是顺应了时代的潮流，第三种版本控制系统问世了。

第三种版本控制系统，称为**分布式版本控制系统**。

分布式版本控制系统，实际上就是前两种的结合体。它在集中化版本控制系统的基础上，给本地客户端加了本地数据库。也就是本地的客户端把远程仓库完整的拉下来，包括历史记录。这样无论服务器怎么故障，本地都可以提交代码，之后只需要在故障后同步远程服务器就可以了。

![图片](https://git-scm.com/book/en/v2/images/distributed.png)

**而 git 就是这样一个分布式版本控制系统。**

**git的诞生和linux内核的开发脱不开关系。**

linux内核开源项目有着为数众多的参与者。1991-2002年间，绝大多数的linux内核维护工作都化在了提交补丁和保存归档的繁琐事物上。2002年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。

好景不长，三年之后，BitKeeper的公司宣布与linux开源社区合作关系结束，收回了BitKeeper在开源社区免费使用的权力。

于是linux社区的开发者们心想，不给我用，那我就自己开发一个。

于是在同一年，git诞生了。此后git不断完善，在高度易用的同时，还拥有飞快的速度，极其适合管理大项目。而且有着令人难以置信的非线性分支管理系统。

如今git被许多公司使用着。也有人说：**git都不会用，写个p的代码。**

>历史总是惊人的相似，当初linux诞生，是因为unix系统不开源。今天git诞生，是因为Bitkeeper不开源。可见开源社区的开发者们，具有极强的创造力。

### 2. git本地的工作流程

这一节讲的，是git的重点。

首先抛出**两种文件**以及他们的概念：

* 已跟踪(tracked)
  
  就是指那些被纳入版本控制的文件。在上一次快照中有他们的记录，在工作一段时间后，又可能会产生特殊的状态（下面会提及）。简而言之就是git知道的文件。

* 未跟踪(untracked)
  
  除了已跟踪文件，别的都是未跟踪。简单的说就是git不知道他们。我们clone下来的仓库中，全部都是已跟踪文件。未跟踪文件产生只有一种情况，就是你在这个目录中，加入了新文件。

然后抛出**已跟踪文件的三个状态**以及他们的概念：

* 已修改(modified)

  表示修改了文件，但还没有保存到数据库中

* 已暂存(staged)

  表示对一个以及修改文件的当前版本做了标记，使之包含在下次提交的快照中

* 已提交(committed)

  表示数据已经安全地保存在本地数据库中，已提交状态还有一个别名，叫做”未修改状态“。

>已暂存要提一嘴，这个对文件做标记包含了两个步骤，第一是计算每个文件的校验和，第二个是会把当前版本的文件快照保存到git仓库中。保存文件到git仓库的并不是提交的步骤，而是暂存步骤。而提交操作是生成提交对象和树对象，这个后面再讲。

其次抛出**三个区域**和他们的概念：

* 工作区(Working Directory)

  工作区是某个版本独立提取出来的内容。是从git仓库的压缩数据库提取出来的文件，然后放在磁盘中给你修改。

* 暂存区(Staging Area)

  暂存区其实就是一个文件，保存了下次将要提交的文件列表信息。一般在git仓库目录中。git的术语也称它为“索引”。

* Git目录(Git Directory/Repository)

  Git目录是git用来保存项目的元数据和对象数据库的地方。这是git中最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。

>git仓库存储的是文件的快照流，并且用文件内容的哈希值来索引。git中所有数据在存储前都计算校验和，然后用校验和来引用。这意味着不可能在git不知情的轻快下更改任何文件内容或目录内容，保证了文件的完整性。

**git本地工作流程：**

我们从clone仓库的流程开始说起。

首先我们通过`git clone`一个仓库，仓库里的所有文件都是已跟踪文件，且状态为未修改/已提交。

然后我们开始写代码。无非就是两种操作，新建文件和修改文件（包括删除）。新建文件就是未跟踪文件。而修改文件本身就是已跟踪文件，修改后状态从已提交/未修改变成已修改状态。

写完后，可以通过`git add`指令将文件放入暂存区。此时新建文件从未跟踪变成已跟踪，且状态变为已暂存。然后修改的文件状态从已修改变成已暂存。

之后通过`git commit`指令就可以向本地仓库提交代码了，两种文件状态都会从已暂存变为已提交/未修改。

![图片](https://git-scm.com/book/en/v2/images/lifecycle.png)

以上就是git本地工作流程。而我们常用的`git push`实际就是和远程仓库同步数据而已。

>顺带一提，git push origin main 中，origin的你远程仓库的默认名。mian的意思是叫做”mian”的分支，在这里是主分支。这个指令的意思是推向远程的主分支。

### 3. git的杀手锏：分支

几乎所有的版本控制系统都支持分支。使用分支可以把你的工作从开发主线上分离开来。但在git出现之前，一般却不推荐使用他们。因为建立分支往往需要创建一个源代码的副本，对于大型的项目来说，会消耗很多时间。

git的分支是特例，实际使用过git的分支后，我们会感觉到建立/删除/合并分支的操作是很高效的。git也正因为它高效的分支特性，才在众多版本控制系统中脱颖而出。~~不愧是git，轻易做到了别的版本控制系统做不到的事情！~~

接下来将会对git的分支做简单的介绍。

### 3.1 存储形式

上面有提及到git存储的是文件的快照。下面我们将进一步深入，了解git存储的形式。

进行提交操作时，git会保存一个提交对象(commit object)。这个对象会包含一个指向暂存内容快照的指针、一个指向它父节点对象的指针和一些基本信息（比如说作者姓名邮件等）。

>需要注意根节点没有指向父节点的指针。

这里举个例子。我们修改了三个文件，现在对他们进行一次提交。

首先是暂存步骤。git首先要做的，是计算每一个子目录的校验和，然后把当前版本的文件快照保存到git仓库中。（git使用blob对象来保存它们），最终校验和加入到暂存区域等待提交。

下一步是提交。git此时会计算每一个子目录的校验和，然后在git仓库中这些校验和保存为树对象，接着创建一个提交对象指向这个树对象。

所以修改了三个文件做提交，一共生成了五个对象。

下面这张图，左边是提交对象，中间是树对象，右边是文件快照。

![图片](https://git-scm.com/book/en/v2/images/commit-and-tree.png)

上图是一个提交对象的结构，提交对象在整个分支中通过指针相连（注意是只有父指针）。最后形成的结构，和单链表竟是如此神似！

![图片](https://git-scm.com/book/en/v2/images/commits-and-parents.png)

### 3.2 git分支的秘密

git分支为何能建得如此之快，那是因为git没有创建源文件的备份，而仅仅只是创建了一个**指向提交对象的可变指针**。

这个指针的名字，其实就是我们的分支名。换句话说，我们的**分支名，其实代表了一个指针**。

很容易想到master这个分支，在多次提交后，master指针会指向最后一个提交对象，也就是这个链表的末尾。当我们新建一个分支的时候，我们建立了一个也指向这个链表末尾的节点。

好家伙，问题来了，两个指针指向同一个节点，我们怎么判断当前所在的分支是哪个节点？

实际上也很简单，它有一个名为HEAD的特殊指针，这个指针指在的提交对象，就是当前所在的本地分支。

![图片](https://git-scm.com/book/en/v2/images/head-to-master.png)

如图，testing是建立新分支时建立的指针，指向末尾节点。HEAD指针指在master上，所以当前就在master分支上。

如果我们此时用checkout指令切换到testing分支，并且做了修改提交，会发生什么事情？

这种情况，testing指针会向前移动，但master指针没有，于是便和master分支发生了分离。如图：

![图片](https://git-scm.com/book/en/v2/images/advance-testing.png)

现在如果我们切换回master分支，会发生两件事情：HEAD指针指回了master分支，并且工作目录恢复成了master分支所指向的快照内容。也就是说整个项目回到了旧的版本，忽略了testing分支所做的改变。

要注意分支切换的时候，会改变你当前的工作目录。如果git不能干净利落的完成这个任务，会禁止切换分支。所以切换分支的时候最好保持工作区是干净的。

>这里就来唠劳分支切换的问题。首先要说的是其实git的工作区和暂存区是不属于任何一个分支的。也就是说你如果本地工作区或者暂存区有未提交的文件，那么，当切换分支的时候，这些文件将会被带过去！这些文件和目标分支文件一旦有冲突，切换分支将会被停止。所以在前还分支前，最好确认目前所在的分支是干净的。

上面说到当前分支切换回了master，那么更进一步。如果当前在master进行了提交，会发生什么？

![图片](https://git-scm.com/book/en/v2/images/advance-master.png)

可见，这样一来master分支就和testing分支产生了分离，他们走向了不同的修改方向。

### 3.3 本地分支的合并

上面提到的master分支和testing分支，不管走向哪儿，最后总是要殊途同归的。下面就要讲讲分支合并的一些东西。

现在有一个场景，请你进入联想：有一个程序员A正在处理别人提的issue53，从主分支拉了一个分支iss53。此时他的老板突然一个电话过来，告诉他有个重大bug需要修复。

这时修bug的任务优先级高过了issue53，需要马上进行。得益于git分支的特性，A不必将issue53与bug的代码混为一谈。他只需要从master再拉一个hotfix的分支进行修复即可。此时hotfix分支的修改和issue原来的修改并不会有任何关联。

现在分支的状态如图：

![图片](https://git-scm.com/book/en/v2/images/basic-branching-4.png)

当bug修完，便可以切回master分支，执行指令`git merge hotfix`。

此时master和hotfix处于一条直线上的关系，master指针只需要移动到hotfix指针所在位置，即可。这个过程称为快进(fast-forward)。

那如果不是master和要合并的分支不是一条直线上的关系呢？

要合并master和iss53：

![图片](https://git-scm.com/book/en/v2/images/basic-merging-1.png)

这个时候执行`git merge iss53`，git会找到master和iss53的最近共同祖先，这里是c2，然后进行c2、master、iss53的三方合并，最后得到一个新的提交对象。

![图片](https://git-scm.com/book/en/v2/images/basic-merging-2.png)

**冲突**

如果两个分支同时改变了同一个文件的同一行，合并会产生冲突。git此时会停下合并，等待用户自己解决冲突。

冲突发生时，我们可以通过`git status`查看到冲突发生的文件。然后通过编辑器，可以对文件进行修改，保留一种形式。

最后通过`git add`指令和`git commit`指令提交即可。

>提pr的时候可以在网页上解决，但是如果冲突文件实在太多，就必须在本地解决了。

### 4. 远程分支

上面我们讲的几乎所有内容，什么分支合并，什么客户端的东西，都是讲本地的git。现在我们要讲到一个远程的git。远程的git我们可谓是天天使用，最具代表性的命令就是`git push`。

在分布式版本管理系统中，我们对本地仓库和远程仓库这两个概念有所提及。本地仓库和远程仓库其实存储着相同的东西。他们之间通过`git push` `git pull`等指令同步数据。

实际上在本地，我们也有存储远程分支，或者说，叫做远程跟踪分支。和普通分支一样，它是一个指针，而且是我们无法移动的指针。远程分支的指针一旦进行网络通信，就会精确地移动到相应的提交对象节点，来反映远程仓库的状态。我们可以形象地将他们看作书签。

远程分支以 `<remote>/<origin>`的形式来命名。像我们的远程master分支，就是`origin/master`。其中origin是默认名，并无实际意义。

![图片](https://git-scm.com/book/en/v2/images/remote-branches-1.png)

这是一个从远程仓库`git clone`的示意图，本地回拉生成一个本地的master分支，同时也会生成一个origin/master的远程跟踪分支。

现在我们对远程分支有了一定认识。远程分支是在远程服务器上的分支，但我们本地也会建立一个指针去跟踪上一次网络通信时，远程分支在我们本地的位置。

那么我们能不能切换到远程分支上呢？答案是可以的，比如说我们想切换到远程的origin/master上，我们只用`git checkout origin/master`。但是因为远程分支（指针）是无法移动的，所以会有提示说，此时我们处于头指针分离状态。

>头指针分离的情况，我们可以修改文件，但提交的对象将不在任何分支上，结果就是这个提交很可能会被清理掉。一般我们需要在这个节点的基础上建立分支，再做修改。返回到以前版本也会出现头指针分离。

很显然，我们也是不能在远程分支上合并分支的。但我们可以在别的分支上合并远程分支。

### 4.1 四个远程通信指令

接下来我们要介绍第一个通信指令`git fetch <remote>`

fetch指令用于拉取远程仓库有的，而本地没有的数据。这意味着，远程的分支也会被拉下来！

![图片](https://git-scm.com/book/en/v2/images/remote-branches-3.png)

如图是一个fetch的流程，本地master进行了提交，远程服务器的master也进行了提交。最后fetch的结果就是origin/master和master产生了分离。这个时候我们可以切换在master上merge一下合并远程分支。

第二个指令`git push <remote> <branch>`相信大家也很熟悉了，就是本地向远程推送。这里可以稍微拓展一下。其实`<branch>`这个选项是可以写成`<branch1:branch2>`这种形式，代表本地分支branch1推到远程分支branch2上。这两个分支实际上是一个分支，只是他们在本地和在远程的名字不同。

举个例子：`git push origin serverfix:awesomebranch`

这里就是将本地的serverfix推送到远程的awesomebranch分支。

第三个指令是`git pull`。

要讲这个指令，首先要提到一个**跟踪分支**的概念。跟踪分支是与远程分支具有直接关系的本地分支。我们在一个跟踪分支上输入`git pull`，git就能自动识别去哪个服务器上抓去，并合并。在功能上来看，pull是fetch+merge。

我们如果在一个本地的远程分支指针上建立一个新分支，那么这个新分支将自动设置为该远程分支的跟踪分支。当然我们也可以手动建立，直接用 `--set-upstream-to`或`-u`选项就可以了。

比如：`git branch -u origin/master` 这就是将当前所在分支设置为远程master分支的跟踪分支。

接下来是最后一个指令`git push origin --delete <branch>`

这样就可以直接删除远程分支，非常简单易懂。

>pr是远程分支合并到远程分支的一种操作。目的是方便code review和多人协作开发。

### 4.2 rebase变基

之前我们讲了合并分支用merge的指令，事实上要合并分支，还有另外一个指令叫做rebase。

rebase和merge没有功能上的区别。唯一的区别就是rebase和merge的提交记录不同，rebase更简洁。

前面说到merge的原理是三方合并，那么rebase如何？

事实上rebase是通过找到两个分支（基底分支和待合并分支）的共同祖先，然后对比待合并分支和祖先的历次提交，提取相应的修改并存为临时文件，然后将HEAD指针指向基底分支，将之前的临时文件修改依次序应用。就像是在基底分支上修改操作进行回放。

![图片](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)

如图，c4的操作在c3这个基底上回放，得到了c4‘这个新的节点。

此后我们可以回到master分支，执行merge，master就只是简单地进行了快进。

![图片](https://git-scm.com/book/en/v2/images/basic-rebase-4.png)

我们使用rebase，一般是为了使提交记录更整洁。但有一个原则，别人如果在我们的分支基础上拉了分支，那么我们这个分支合并时不能用rebase。

因为别人的分支本来建立在我们分支的基础上。别人要合并的时候，就可能会把我们通过rebase舍弃的记录又找了回来，而且使得记录更加混乱了。~~当然这个情况要触发，条件还蛮苛刻的。~~

### 5. 分支开发工作流

讲了那么多，最后来唠劳开发工作流。比较常见的，就两种，长期分支和主题分支。

**长期分支**

长期分支可以想像成一条流水线。我们把稳定的版本放在master上，然后拉各种开发分支来开发各种功能。在开发过程中，可能遇到一些模块功能，那么就再拉一个分支去开发。等这些分支开发的稳定性达到一定程度，就可以向上合并，最后合并到master，等待下一次发布。

长期分支的master和其他开发分支之间的提交记录往往是相差甚远的。

![图片](https://git-scm.com/book/en/v2/images/lr-branches-2.png)

长期分支可以维护不同层次的稳定性。适合用于大型项目，许多公司也沿用了这样的一个工作流。

**主题分支**

主题分支对任何规模的项目都适用。主题分支是一种短期的分支，被用来实现单一特性或其他相关工作。

![图片](https://git-scm.com/book/en/v2/images/topic-branches-1.png)

简单来说，就是一个项目分了不同服务来写。彼此之间不用互相影响，也不用考虑某一个服务的进度问题。最后只要把分支合并就可以了。我们团队现在就用这种工作流。