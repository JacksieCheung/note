## 初步了解 git

本文所有内容都出自[git-book](https://git-scm.com/book/zh/v2)，主要目的是了解git。

### 1. git 的本质

git是一个版本控制系统。

所谓版本控制，就是一种记录一个或若干文件**内容变化**，以便将来**查阅特定版本**修订情况的系统。

根据版本控制的定义，不难看出，git具有记录文件变化的功能（也就是备份），可以随时进行文件的回溯。

举个例子更好理解回溯功能的需求：A在开发一个软件，发布了非常稳定的版本1。然后有人给A提了issue，A立马就开始写，发布了版本2。结果他发现，版本2涉及到了一些问题，不能正常使用。（比如说侵权、以前版本中的重大bug等）

在上面这个例子中，版本2由于一些问题不能正常使用，A这个人可能会做的一件事情就是删掉版本2中比版本1多出来的代码。也就是**将整个项目回到版本1**。

那A具体要怎么做呢，手动删掉吗？那好像也删不干净。可能在写版本2的代码时，会和版本1的代码形成高度耦合，要改得花很多时间精力。

为了不出现手动改的麻烦，不难想到一个操作，就是在开发版本2前，手动复制代码。通过改名和标注时间等方式加以区分。这样做的唯一好处就是简单，但特别容易犯错，万一混淆了工作目录，一不小心覆盖了某个文件，就改不回来了。

因此针对将版本回溯的需求，版本控制系统应运而生。

### 1.1 git的前世今身

第一种开发的版本控制系统，叫做**本地版本控制系统**。它的原理是用简单的数据库来记录文件的历次更新差异。其中最流行的叫做RCS，它在硬盘上保存补丁集，通过应用所有补丁集，可以重新计算出各个版本的文件内容。

![图片](https://git-scm.com/book/en/v2/images/local.png)

>补丁的意思就是文件修改前后的变化，RCS记录的是文件之间的变化，也就是类似某一行删了，某一行改了，某一行加了这种变化。

其实有了本地版本控制系统，基本上就解决了我们前面讲到的版本回溯的需求。但版本控制系统的作用并没有止步于此。在开发项目中需要用到版本控制的，基本都有一个特点就是规模庞大。而大型项目往往需要多人协同开发。所以第二个需求便体现出来了：如何让不同系统的（或者远程的）开发者一起来开发同一个项目？这就有了第二个版本控制系统。

第二种开发的版本控制系统，叫做**集中化的版本控制系统**。这个版本控制系统有一个单一的集中管理服务器保存所有文件的修订版本。各用户只需要通过客户端连接到这台服务器，就能够取出最新的文件或者提交更新。

![图片](https://git-scm.com/book/en/v2/images/centralized.png)

上面是模型图。和本地版本控制系统的区别就是本地不再存储文件版本，而改为只有远程一个存储文件的服务器。不难理解集中化，指的就是多用户的版本集中化管理。本地的客户端，只是一个提交本地文件快照的工具。

>快照，指的是备份某一个时间点的文件。这个时间点的文件备份后，原文件可以改变，但备份出来的那部分文件就不再改变了。这个过程就像现实世界中给文件进行拍照，所以称为快照。

然而集中化版本控制系统并不稳定。如果中央服务器崩了，那么这个过程中谁都无法提交修改。于是，也是顺应了时代的潮流，第三种版本控制系统问世了。

第三种版本控制系统，称为**分布式版本控制系统**。

分布式版本控制系统，实际上就是前两种的结合体。它在集中化版本控制系统的基础上，给本地客户端加了本地数据库。也就是本地的客户端把远程仓库完整的拉下来，包括历史记录。这样无论服务器怎么故障，本地都可以提交代码，之后只需要在故障后同步远程服务器就可以了。

![图片](https://git-scm.com/book/en/v2/images/distributed.png)

**而 git 就是这样一个分布式版本控制系统。**

**git的诞生和linux内核的开发脱不开关系。**

linux内核开源项目有着为数众多的参与者。1991-2002年间，绝大多数的linux内核维护工作都化在了提交补丁和保存归档的繁琐事物上。2002年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。

好景不长，三年之后，BitKeeper的公司宣布与linux开源社区合作关系结束，收回了BitKeeper在开源社区免费使用的权力。

于是linux社区的开发者们心想，不给我用，那我就自己开发一个。

于是在同一年，git诞生了。此后git不断完善，在高度易用的同时，还拥有飞快的速度，极其适合管理大项目。而且有着令人难以置信的非线性分支管理系统。

如今git被许多公司使用着。也有人说：**git都不会用，写个p的代码。**

>历史总是惊人的相似，当初linux诞生，是因为unix系统不开源。今天git诞生，是因为Bitkeeper不开源。可见开源社区的开发者们，具有极强的创造力。

### 2. git本地的工作流程

这一节讲的，是git的重点。

首先抛出**两种文件**以及他们的概念：

* 已跟踪(tracked)
  
  就是指那些被纳入版本控制的文件。在上一次快照中有他们的记录，在工作一段时间后，又可能会产生特殊的状态（下面会提及）。简而言之就是git知道的文件。

* 未跟踪(untracked)
  
  除了已跟踪文件，别的都是未跟踪。简单的说就是git不知道他们。我们clone下来的仓库中，全部都是已跟踪文件。未跟踪文件产生只有一种情况，就是你在这个目录中，加入了新文件。

然后抛出**已跟踪文件的三个状态**以及他们的概念：

* 已修改(modified)

  表示修改了文件，但还没有保存到数据库中

* 已暂存(staged)

  表示对一个以及修改文件的当前版本做了标记，使之包含在下次提交的快照中

* 已提交(committed)

  表示数据已经安全地保存在本地数据库中，已提交状态还有一个别名，叫做”未修改状态“。

>已暂存要提一嘴，这个对文件做标记包含了两个步骤，第一是计算每个文件的校验和，第二个是会把当前版本的文件快照保存到git仓库中。保存文件到git仓库的并不是提交的步骤，而是暂存步骤。而提交操作是生成提交对象和树对象，这个后面再讲。

其次抛出**三个区域**和他们的概念：

* 工作区(Working Directory)

  工作区是某个版本独立提取出来的内容。是从git仓库的压缩数据库提取出来的文件，然后放在磁盘中给你修改。

* 暂存区(Staging Area)

  暂存区其实就是一个文件，保存了下次将要提交的文件列表信息。一般在git仓库目录中。git的术语也称它为“索引”。

* Git目录(Git Directory/Repository)

  Git目录是git用来保存项目的元数据和对象数据库的地方。这是git中最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。

>git仓库存储的是文件的快照流，并且用文件内容的哈希值来索引。git中所有数据在存储前都计算校验和，然后用校验和来引用。这意味着不可能在git不知情的轻快下更改任何文件内容或目录内容，保证了文件的完整性。

**git本地工作流程：**

我们从clone仓库的流程开始说起。

首先我们通过`git clone`一个仓库，仓库里的所有文件都是已跟踪文件，且状态为未修改/已提交。

然后我们开始写代码。无非就是两种操作，新建文件和修改文件（包括删除）。新建文件就是未跟踪文件。而修改文件本身就是已跟踪文件，修改后状态从已提交/未修改变成已修改状态。

写完后，可以通过`git add`指令将文件放入暂存区。此时新建文件从未跟踪变成已跟踪，且状态变为已暂存。然后修改的文件状态从已修改变成已暂存。

之后通过`git commit`指令就可以向本地仓库提交代码了，两种文件状态都会从已暂存变为已提交/未修改。

![图片](https://git-scm.com/book/en/v2/images/lifecycle.png)

以上就是git本地工作流程。而我们常用的`git push`实际就是和远程仓库同步数据而已。

>顺带一提，git push origin main 中，origin的你远程仓库的默认名。mian的意思是叫做”mian”的分支，在这里是主分支。这个指令的意思是推向远程的主分支。

### 3. git的杀手锏：分支

几乎所有的版本控制系统都支持分支。使用分支可以把你的工作从开发主线上分离开来。但在git出现之前，一般却不推荐使用他们。因为建立分支往往需要创建一个源代码的副本，对于大型的项目来说，会消耗很多时间。

git的分支是特例，实际使用过git的分支后，我们会感觉到建立/删除/合并分支的操作是很高效的。git也正因为它高效的分支特性，才在众多版本控制系统中脱颖而出。~~不愧是git，轻易做到了别的版本控制系统做不到的事情！~~

接下来将会对git的分支做简单的介绍。

### 3.1 存储形式

上面有提及到git存储的是文件的快照。下面我们将进一步深入，了解git存储的形式。

进行提交操作时，git会保存一个提交对象(commit object)。这个对象会包含一个指向暂存内容快照的指针、一个指向它父节点对象的指针和一些基本信息（比如说作者姓名邮件等）。

>需要注意根节点没有指向父节点的指针。

这里举个例子。我们修改了三个文件，现在对他们进行一次提交。

首先是暂存步骤。git首先要做的，是计算每一个子目录的校验和，然后把当前版本的文件快照保存到git仓库中。（git使用blob对象来保存它们），最终校验和加入到暂存区域等待提交。

下一步是提交。git此时会计算每一个子目录的校验和，然后在git仓库中这些校验和保存为树对象，接着创建一个提交对象指向这个树对象。

所以修改了三个文件做提交，一共生成了五个对象。

下面这张图，左边是提交对象，中间是树对象，右边是文件快照。

![图片](https://git-scm.com/book/en/v2/images/commit-and-tree.png)

上图是一个提交对象的结构，提交对象在整个分支中通过指针相连（注意是只有父指针）。最后形成的结构，和单链表竟是如此神似！

![图片](https://git-scm.com/book/en/v2/images/commits-and-parents.png)

### 3.2 git分支的秘密

git分支为何能建得如此之快，那是因为git没有创建源文件的备份，而仅仅只是创建了一个**指向提交对象的可变指针**。

这个指针的名字，其实就是我们的分支名。换句话说，我们的**分支名，其实代表了一个指针**。

很容易想到master这个分支，在多次提交后，master指针会指向最后一个提交对象，也就是这个链表的末尾。当我们新建一个分支的时候，我们建立了一个也指向这个链表末尾的节点。

好家伙，问题来了，两个指针指向同一个节点，我们怎么判断当前所在的分支是哪个节点？

实际上也很简单，它有一个名为HEAD的特殊指针，这个指针指在的提交对象，就是当前所在的本地分支。

![图片](https://git-scm.com/book/en/v2/images/head-to-master.png)

如图，testing是建立新分支时建立的指针，指向末尾节点。HEAD指针指在master上，所以当前就在master分支上。

如果我们此时用checkout指令切换到testing分支，并且做了修改提交，会发生什么事情？

这种情况，testing指针会向前移动，但master指针没有，于是便和master分支发生了分离。如图：

![图片](https://git-scm.com/book/en/v2/images/advance-testing.png)

现在如果我们切换回master分支，会发生两件事情：HEAD指针指回了master分支，并且工作目录恢复成了master分支所指向的快照内容。也就是说整个项目回到了旧的版本，忽略了testing分支所做的改变。

要注意分支切换的时候，会改变你当前的工作目录。如果git不能干净利落的完成这个任务，会禁止切换分支。所以切换分支的时候最好保持工作区是干净的。

>这里就来唠劳分支切换的问题。首先要说的是

上面说到当前分支切换回了master，那么更进一步。如果当前