## 从 RPC 到 gRPC 到 微服务 到 工作台

### rpc 简述

rpc，全称 remote procedure calls（远程过程调用）。啥叫过程调用？简单的来讲就是函数调用。再加个“远程”的前缀，就是一个进程调用**远程的**另一个进程的函数的意思。rpc 常用于分布式系统中，两个进程可以在一个机器上，也可以在不同机器上。rpc 通过封装，使程序员得以忽略网络通信的细节，实际使用起来，就像在本地上调用函数一样。

 rpc 是一种抽象的概念，我认为它比较像一种标准，或者说规范。它有很多实现，实现方法可以基于 TCP，也可以基于UDP。单说 rpc 说实话我也说不清楚，但是我接触过 rpc 的一种实现——grpc。所以下面可以详细讲讲 grpc 。

### gRPC 工作流程

#### 开发流程

要使用 grpc，首先我们需要生成桩代码。这里要用到 protobuf（下面会提及），我们可以事先写好 proto 文件，规定程序交互的接口。简单的来说就是规定好每个函数接收参数的结构和返回数据的结构。

然后用 protoc 编译器生成对应语言的桩代码（占坑代码的意思），包括服务端的代码和客户端的代码，都是一些封装好的函数。我们只需要在自己的程序里调用这些函数，就能实现程序之间的函数调用。

值得注意的是服务端的函数还是需要我们手动实现，也就是我们需要写的业务逻辑（要是业务逻辑都能生成了那真是太好了）。那这里的桩代码生成了个啥？答案是生成了封装程序间通信的代码。这其实是基于定义服务的思想，定义了这个服务端的函数叫什么、有什么参数、返回什么，之后我们再对这个函数进行具体的实现。

当客户端调用这些函数时，便会向服务端发送请求，客户端进入等待。服务端收到请求、经过处理后会返回一个响应。客户端收到该响应，继续往下执行。在程序员看来，简直就像是本地调用函数，grpc 为我们隐藏了底层的细节。

#### 通信流程

gRPC 基于 HTTP/2 。

HTTP/1.1 是以前常用的版本，现在的网站 HTTP/2 和 HTTP/1.1都有，但还是 HTTP/2 的请求比较多。（像b站、知乎、bing 等）。 HTTP/2 是 HTTP/1.1 的升级版，在后者基础上引入了流的概念。即将一个请求拆分成一段一段数据帧，通过I/O多路复用技术并发发送，提高了资源利用率。

而 gRPC 在 HTTP/2 的基础上进行了封装，引入了通道、rpc 和消息。

gRPC通过封装，在应用层面只有一条虚拟的通道与服务端相连。实际上，其底层有多条 HTTP/2 的连接。gRPC 建立连接池定期更新、检查和管理这些连接，从而做到多连接、每条连接上并发请求的多级并发模式。

而 rpc 在这里的实现，其实就是用 HTTP/2 传输的请求。消息就是将这个请求拆分成更小的单元，于其大小有关，可以一个消息横跨多个数据帧，也可以是一个数据帧发送多个请求。

### protobuf

下面来拓展一下 protobuf 的相关知识。

protobuf 是 grpc 默认的接口定义语言(IDL)和底层消息交换格式。什么叫接口定义？就是我们上面讲到的写 proto 文件，如下：

```protobuf
syntax = "proto3";

package status;

service TestService {
  rpc Get(GetRequest) returns (GetResponse) {}
}

message GetRequest {
  uint32 id = 1;
  uint32 uid = 2;
}

message GetResponse {
  Status status = 1;
}
```

消息交换格式，就是网络请求时传输的格式，可以类比 JSON。

### 微服务

微服务，是新提出的一种服务架构，是把传统的一体化服务拆开成数个较小的服务。一个显而易见的特点是：传统一体化服务只有一个 `main.go` 而微服务有多少个服务就有多少个 `main.go`。

#### 服务拆分

拆分的方式实际上没有一个很好的定论，最简单的就是按业务模块拆分（按数据库表拆分）。比如说工作台的进度和项目就是两个不同的业务模块，就可以拆开。不过无论如何拆分，都要遵循 “高内聚，低耦合”的原则。

> 高内聚低耦合：高内聚是把逻辑和功能相关度放在一起，把无关的分开。低耦合是减少模块和模块之间的通信，通信越多，耦合程度越高，越容易牵一发而动全身。

服务拆分实际上是增加了一个程序的边界，提高内聚性，增强逻辑性。而实际开发也要尽量减少服务之间的通信，降低耦合性。总结一句话就是：紧密关联的处理，放在一个服务内，避免在服务与服务之间共享数据。

#### 微服务优点

* 微服务拆分大服务为小服务，使得服务更易于开发和维护了。在实际开发中，因为每个被拆分的服务只干自己的事情，所以开发过程中逻辑性是比较好的，比较容易开发。（个人体会）

  写服务总是需要维护，这个时候只需要单独针对某个特定的服务维护就行了，相比于维护一体化的服务，看的代码少了，减少了眼花的概率。而且如果想尝试别的技术重构，微服务的独立性也可以安全的部分重构。

* 微服务可提高资源利用率，减轻硬件压力。每个拆出来的服务有独立的`main.go`，可以部署到不同的机器上，形成分布式系统。

* 微服务灵活性强。不同的服务可以用不同语言实现，服务之间的通信协议也可以替换，做到因地制宜。这也被称为可插拔性。

#### 微服务的缺点

* 微服务虽然开发简单了，但是运维就复杂了。每个服务都要分开部署，可能也需要 k8s 这样的集群管理工具去管理。而且服务之间通信的安全，也需要考虑。
* 微服务的性能可能会受影响。服务是独立的，但服务之间还是存在通信的。这部分通信需要经过网络，相比一体化的服务进程内调用，微服务的远程调用所用时间肯定是长了。

### 从微服务到工作台

下面以工作台为例，直观的看一下微服务是什么。

工作台用到了 go-micro 这个微服务框架。go-micro 是14年推出的 go 语言微服务框架，现在都已经出到 3.6 版本了，而工作台用的是 1.5 的上古版本。现在 go-micro 已经不怎么更新了，作者和他的团队认识到要开发微服务，一个框架并不够，于是跑去开发一个叫做 Micro 的微服务工具箱，他们把这个叫做本地云原生微服务开发平台。（下文再讲）总之，go-micro 是 go 语言在微服务初期的尝试。

#### 工作流程

go-micro 使用 grpc 作为服务间的默认通信协议。工作台使用默认的 grpc。

下面是工作台服务的大致目录结构：

```go
workbench-be
	|
	|----service
	|				|
....			|----feed
					|
					|----status
					|
					|----project
					|
					|----team
					|
					|----user
					|
					|----gateway
```

可以看出，工作台将服务拆成了六个小服务，从上往下分别是：动态、进度、项目、团队、用户和网关。

其中 feed、project、status、team、user 都只暴露 rpc 接口，提供服务间通信。而 gateway 对外（给前端）暴露 http 接口，并将得到的请求映射到对应的 rpc 接口上（就是统一调用其他 rpc 服务的意思）。所以整个工作流程如下：

```go
                               						| feed 
  http request             RPC request    | status
----------------> gateway --------------> | project
																					| user
																					| team
```

#### 实际代码

下面是 gateway 里的创建进度接口。实际和 status 服务通信就是调用`Create`函数，非常简单。

这个函数的函数名、参数列表、返回值（即函数签名）在 protobuf 里定义，然后生成桩代码。而函数内部的业务逻辑需要由我们手动实现。

/gateway/status/handler/create.go

```go
	// 构造 create 请求
	createReq := &pbs.CreateRequest{
		Title:   req.Title,
		Content: req.Content,
		UserId:  userId,
	}

	// 向创建进度发起请求
  // 在这里调用
	_, err := service.StatusClient.Create(context.Background(), createReq)
	if err != nil {
		SendError(c, errno.InternalServerError, nil, err.Error(), GetLine())
		return
	}
```

### Micro 

可以简单聊聊 Micro，我只看了点文档。Micro 据作者自己说，就像一个微服务的操作系统（当然不是真正的操作系统，只是对于微服务这个程序来说有点像）。服务运行的时候，Micro 是透明的。Micro 能够帮助微服务注册、提供服务发现功能，提供 rpc 和 http 两种接口。具体来说就是一些封装好的工具，可以在开发过程中使用。具体怎么使用我也没用过，看文档比较玄乎，所以就不多说了。

### 小结

微服务和传统的一体服务各有优劣，在实际开发中，还是建议先开发一体化服务，有需要再按照微服务拆分。

在团队实际开发中，老板说我们现在写的服务太小了，不需要用到微服务，工作台只是一个尝试。所以本科生期间，应该是不会写微服务项目的，除了接手工作台。

### 参考

* https://micro.mu/introduction
* https://github.com/asim/go-micro
* https://www.cncf.io/blog/2018/07/03/http-2-smarter-at-scale/
* https://zhuanlan.zhihu.com/p/37387316
* https://pingcap.com/zh/blog/grpc

