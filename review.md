## 论 code reviewer 的个人修养



### 1. db.sql

sql文件写得比我想象中好得多。我在你们仓库里找了很久，也找不出什么大问题，感觉是在鸡蛋里面挑骨头。所以就说说写得好的，还有一些我看得不是很顺眼的地方。

**问题：**

* 八格缩进问题和缩进缩的问题
* 表的主键可以直接缩写成 “id”
* 创建索引的语句可以写在表结构里面
* 建表需要设置字符集
* 主键不需要再加 UNIQUE 约束，只有经常查询的字段才需要加索引
* 建表用 if not exists 有点多余

**亮点：**

* 用到了 BIGINT 和 TINYINT， 很好，但是还可以在后面加上(1)等使范围更加缩小。比如 TINYINT(1)这种。
* 命名规范整体还行（除了有些前缀有点多余）

### 2. commit 规范

虽然我在项目开始之初就已经跟你们反复强调再强调这个 commit 规范了，但是你们的这个 commit 还是在预料之中的不规范。

不过整体下来，也比我们去年写得好。

**这里再强调一下规范问题：**

github 的 commit 应该包含四个部分： type scope subject body

分别表示提交修改的类型、提交修改的范围、提交修改的简短描述和提交修改的详细描述

其中 type 和 subject 是必须的。

**type有以下几种：**

**feat:** 新功能

**fix:** 修复 bug

**docs:** 文档改变

**style:** 代码格式改变

**refactor:** 某个已有功能重构

**perf:** 性能优化

**test:** 新增加测试/测试用例

**revert:** 撤销上一次 commit

**chore:** 改变构建流程、或者增加依赖库、工具等

**init:** 新建库

**build:** 改变了 build 工具

**subject的格式：**

简短描述，不超过50个字。多用动词开头，首字母小写，不加句号。

**一个例子：**

```
   fix:fix login part of user service
```

当然，也可以像 token 他们那样 commit ：

``` 
   [fix]:fix token resolved codes
```

### 3. 目录结构

因为在写之前就和你们说了，所以整体上看没什么问题。基本都有分文件来写。

有些文件夹是空的，完全用不上，可以删掉。比如说自控力的 service 文件夹。（其他好像都删了）

**model 和 service**

下面来说说这俩玩意的关系

model 文件夹是存放数据库相关的操作，说简单点就是对单个表的增删查改的。

service 文件夹存放实际业务处理函数

那么这两个有啥区别呢？

有些服务我们需要调用多个表的增删查改函数，这时候就需要 service 下的文件对它们进行统一调用。

举个例子，获取一个帖子的列表，我们返回的结果需要知道它们每个单独成员的点赞情况。这个时候就需要获取列表，和每个列表的点赞情况，然后做一个遍历比较。

不过，当一个服务只需要对一个表进行增删查改时，用 service 就显得多余了，这个时候 handler 直接调用 model 的函数就够了。

**同时改变两个表需要用到事务**

比如说点赞这个服务，需要同时插入点赞的关系表和修改点赞数。这个时候有个问题，两个操作中，如果有一个操作失败了，那么最后的结果就是一个表改了，另一个表没改，造成了数据的不一致。

这个时候就用到了事务。使用事务后，一旦有表操作失败，就会进行回滚，保证数据一致。

**验证 token 可以使用中间件**

每次都在 handler 里手动调用非常麻烦，用中间件就方便很多。

中间件是每次调用 handler 之前会优先调用的函数。路由组调用一次，整个路由组都能使用。不用每个handler都写，非常方便。

然后解析出来的 id 可以通过 context 传给 handler。

然后 token 解析出来是不用放到数据库里面去检验的。

**util 和 pkg**

util 是工具包，其实你们现在完全用不上，以后看项目模板就好了。

然后 pkg 是项目引用的包，多个服务共同调用的一些函数或者变量需要放在这里。

自定义的错误应该放在 pkg 里面。除了自定义错误，还可以放用户认证相关、token、自定义常量等。

**SendResponse 和 SendRequest**

request 和 response 都是需要定义结构体的，但是这两个结构体不应该定义在 model 文件夹下。

前面也说了，model 是存放数据库表操作函数的地方，而请求和响应不是。

所以请求和响应需要额外找地方建，这个地方就是每个 handler 的文件夹。

举个例子，user 服务需要在 handler 下建一个 user.go，然后在里面放我们的请求和响应结构体。并且命名规范需要注意。比如`CreateUserRequest`这种。

**config**

数据库账号和密码不应该写死在代码里。

一方面是安全的问题。我们连接的数据库，不一定是本地的。如果我们写死在了代码里，任何人都能通过查看你的githhub仓库找到账号密码来登陆你的远程数据库。

另一方面也是为了方便修改。要修改链接的数据库时，只需要修改配置文件，不用修改代码本身。而写死在代码里，就只能修改代码了。

另外配置文件不仅仅可以存放数据库的账号密码，对于一些会随着时间变化而需要修改的常量，也可以通过配置文件读取。

### 4. 路由

**路由分组**

每次写路由都要反复复制粘贴一系列前缀，真的不累吗？

路由分组能很好的节省工作量，而且使得路由更简洁。

**路由命名**

我们开发后端接口，使用的是 restful 规范。

在 restful 规范中，每个路由，代表一个资源。资源就是资源，就是对象的本身，不具有任何操作的性质。

举个例子，用户这个资源就是 user 吧？不应该有 user_edit, user_add, user/delete 。在后面加后缀，就有点画蛇添足了。

我能理解你们的想法，是想让路由的命产生操作上的区分。但是别忘了，已经有一个东西可以体现操作上的不同，那就是 http 方法。

举个典型的例子，针对用户的增删查改：

```go
   userRouer := router.Group("/user")
   {
       userRouter.POST("",...)
       userRouter.DELETE("/detail/:id",...)
       userRouter.GET("/detail/:id",...)
       userRouter.GET("/list",...) // 获取列表
       userRouter.PUT("",...)
   } 
```

仔细看会发现不少路由都是一样的，我们根据方法区分完全够了。

另外路由中是否要写上路径参数，其实是根据需求来的。如果能在 token 中获取 id，那么就不需要了。

**获取列表时，应当用分页**

获取列表服务，一般都使用分页。如果一次性返回全部数据，前端或者安卓需要处理太多。而且我们自己查询数据库也慢，使接口性能下降。

所以就有了分页的一个处理。

分页处理需要传递几个查询参数（路由参数）：page 和 limit

有些还有 last_id ，不过一般 page 和 last_id 用一个即可实现分页。

page 表示页数，limit 表示每一页的最大个数限制。

在 handler 中，接受这两个参数，然后用 page * limit 得到新的变量 offset。 offset 表示偏移量，稍后会用它和 limit 进行查询。

```sql
  select * from user order by id desc offset [offset] limit [limit];
```

上面是一个查询的示例，在实际使用 gorm 中，我们直接调用 offset 和 limit 方法就可以了。

### 5. 其它

**注释**

注释也是有规范的，需要在`//`后面空一格，如：

```go
   // 搜索界面
```

**命名规范**

驼峰命名啊驼峰命名，怎么还有人不是驼峰命名？

`adddigest.go`这一排 d 真是看得我一愣一愣的。

**能一次获取全部字段，为何要一个一个查**

这段代码挺雷人的吧

```go
    MyName := model.GetUserName(id)
	MyPicture := model.GetUserPicture(id)
	MyMotto := model.GetUserMotto(id)
	userinfo := model.Userinfo{UserName: MyName, UserPicture: MyPicture, Motto: MyMotto}
```

最雷的是每个这个 model 里面的函数都是获取完整的表信息！

真当表查询不用消耗时间呗？

原则上，表查询能少则少。查询数据库是需要时间开销的（就算会做缓存），上面那个查那么多次做了很多无用功。能一次完成的就一次完成吧。

### Finally 总结

miniproject 基本完成，你们写得还是挺不错的，应该比我当年同期要好。有些地方还是比较两眼的，像 strings.Index， 还有一些代码的格式写得比较舒服。