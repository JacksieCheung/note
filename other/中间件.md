### 中间件

今天的主题是业务中间件。

#### 1. redis

* 为何使用？

  redis 是完全基于内存，底层实现是哈希表，并发模型是单进程单线程的键值对存储数据库。

  优点很明显了，就是足够快，不需要像 mysql 去查聚簇索引。

  另一个优点就是单线程的模式足够小，即使在性能不那么好的机器上也能稳定发挥。

  redis 应该是我们团队最常使用的中间件，~~（我好像没见过团队用其他的）~~

  我们常用来做 mysql 的缓存和一些异步进程通讯的操作。

  不过需要注意一点，redis 是完全基于内存的，如果突然断电了，redis 存的信息会全部丢失。所以存到 redis 的信息，都需要从数据库中得到。

  > 什么叫缓存？就是我们把 mysql 中的信息存到 redis。为什么要做缓存？因为 redis 够快，当查询比较多的信息时，性能提升较大。此外，有一些信息可能是 mysql 本身不方便存储的，（要多建表比较麻烦，例如工作台的 project 服务）我们可以通过查表计算出这些信息，并存到redis。

* 如何安装？

  直接上官网就好了：https://redis.io/download

  应该没什么难度。进入 src 文件夹后，有 redis-cli 和 redis-server 两个可执行文件

  一个是启动 redis 的客户端，一个是启动 redis 的服务端

  如果不想每次启动 redis 都打开文件夹怎么办呢？可以设置环境变量。

  不过呢，redis 给我们提供了 Makefile ，我们可以看看 README.md：

  ```markdown
  Installing Redis
  -----------------
  
  In order to install Redis binaries into /usr/local/bin, just use:
  
      % make install
  
  You can use `make PREFIX=/some/other/directory install` if you wish to use a
  different destination.
  ```

  直接输入指令 `make install` 就可以了。

* 如何使用？

  * 基本指令

    这里就不一一列举了，给出网站，基本都有: http://doc.redisfans.com/

  * 基本数据类型

    和 mysql 不同的是，redis 是key-value 数据库。也就是相当于一个大型的哈希表。（整个存储结构也是，不同数据结构的区别就在于 key 对应的结构不同）

    在这样一个数据库中，有五种基本的数据类型：string、set、zset、list、hash 五种。

    分别是 字符串、集合、有序集合、哈希表。

    * string

      字符串是最泛用的数据类型，书上提到了可以用来缓存用户信息。就是将用户信息的结构体序列化成 json 格式，并作为字符串形式存入 redis。

      **使用场景：**

      具体在什么场景下能缓存用户信息，我现在还没遇到过。不过呢，在我们团队的工作台中，用到了 string 来缓存过期 token，也就是做 token 的黑名单。

    * set

      集合可以看作是一个特殊的哈希表，只不过哈希表里面所有的 value 都是 NULL。

      **使用场景：**

      书上提到，set 可以用来存储用户中奖信息。这是因为用到了集合的自动去重功能（其实就是哈希表的去重）。所以一个用户不可能中奖两次。在团队实际应用中，工作台的回收站就有用到 set，下面就说说具体实现：

      当删除一个文件时，要么删文件，要么删文件夹。mysql 只存储被删的对象本身，后面的任务交给定时任务做。如果是文件夹，定时任务需要遍历出它的所有子文件夹和子文件，并存到 redis。如果是文件本身就直接存到 redis。这样做的一个好处就是我们不用多次插入数据库。如果每次删除文件夹都需要递归遍历修改数据库，会非常非常的慢。如果只是插入这个被删除的对象本身，而遍历拿出子文件夹的过程交给子协程定时任务做，会快得多。（所谓子协程就是 go 开启的函数）

    * zset

      有序集合是 redis 最有特色的数据结构，它典型的作用就是能快速给出降序升序排序，而且插入数据和获取数据都非常快。虽然我现在遇到的开发场景都太小，还没在实战中用过。它底层实现是经典的跳跃列表，也是经常被面试官问到的东西。当然这里只是介绍 redis，并不会讲到底层的东西。

      **使用场景：**

      书上提到，zset 可以用来存储粉丝列表，member 值是粉丝的用户 ID，score 是关注事件，key 可以是这个用户的 ID。这样我们可以对粉丝按照关注时间进行排序。zset 还可以用来存学生成绩，score 是成绩，就可以按照成绩排序。

    * hash 和 list

      list可以实现简单的消息队列。这两个我没有深入了解过，就不多讲了。

  * pub-sub

    翻译过来就是 发布者-接受者。这是 redis 里面支持消息多播的机制。什么叫消息多播？就是一个发布者发布信息可以被多个接受者收到。其实前面的 list 类型就可以实现消息队列，（看作一个队列）但是不支持消息多播，所以就有了 pub-sub 的机制。

    **使用场景：**

    pub-sub可以应用于实现实时聊天的功能和博客的粉丝文章的推送。我们团队工作台用过这个来实现进程间的异步通信。

    **案例，多人聊天室**

    REDIS/chat/model/model.go

    ```go
  package model
    
  import (
    	"fmt"
  
    	"github.com/go-redis/redis"
    )
    
    type Redis struct {
    	Self *redis.Client
    }
    
    type PubSub struct {
    	Self *redis.PubSub
    }
    
    var (
    	PubSubClient *PubSub
    	RedisDB      *Redis
    )
    
    func (*Redis) Init() {
    	RedisDB = &Redis{
    		Self: OpenRedisClient(),
    	}
    }
    
    func (*Redis) Close() {
    	_ = RedisDB.Self.Close()
    }
    
    func (*PubSub) Init(channel string) {
    	PubSubClient = &PubSub{
    		Self: OpenRedisPubSubClient(channel),
    	}
    }
    
    func (*PubSub) Close() {
    	_ = PubSubClient.Self.Close()
    }
    
    // OpenRedisClient opens a redis client with the addr and password getting from env or config file
    func OpenRedisClient() *redis.Client {
    	r := redis.NewClient(&redis.Options{
    		Addr:     "127.0.0.1:6379",
    		Password: "",
    		DB:       0,
    	})
    
    	if _, err := r.Ping().Result(); err != nil {
    		fmt.Println("open redis error.")
    	}
    	return r
    }
    
    // OpenRedisPubSubClient opens a redis pubSub client
    func OpenRedisPubSubClient(channel string) *redis.PubSub {
    	return OpenRedisClient().Subscribe(channel)
    }
    
    func PublishMsg(msg string, name string) error {
    	return RedisDB.Self.Publish(name, msg).Err()
    }
    ```
  
    REDIS/chat/main.go
  
    ```go
    package main
    
    import (
    	"REDIS/chat/model"
    	"fmt"
    	"log"
    	"os"
    	"strings"
    )
    
    const name = "sub"
    
    func main() {
    	if len(os.Args) == 1 {
    		panic("usage:go run main.go <yourname>")
    	}
    
    	username := os.Args[1]
    
    	model.RedisDB.Init()
    	defer model.RedisDB.Close()
    
    	model.PubSubClient.Init(name)
    	defer model.PubSubClient.Close()
    
    	go listen(username)
    
    	for {
    		var item string
    		fmt.Scanln(&item)
    		msg := fmt.Sprintf("%s-%s", username, item)
    		model.PublishMsg(msg, name)
    	}
    }
    
    func listen(username string) {
    	ch := model.PubSubClient.Self.Channel()
    	for msg := range ch {
    		tmp := strings.Split(msg.Payload, "-")
    		if tmp[0] != username {
    			log.Println(tmp[0], ":", tmp[1])
    		}
    	}
    }
    ```
  
  * go-redis 包
  
    这是团队用得比较多的包。https://github.com/go-redis/redis

#### 2. Rabbitmq

* 如何安装？

  mac 可以直接用 brew 安装

  linux 上官网看看 https://www.rabbitmq.com/install-debian.html

* 如何使用？

  * 讲用法没意思，直接上网址：

    https://www.rabbitmq.com/getstarted.html

  * 模型图

    ![Publish path from publisher to consumer via exchange and queue](https://www.rabbitmq.com/img/tutorials/intro/hello-world-example-routing.png)

    rabbitmq 不同于 redis，它不是数据库，而是专门做消息队列的。

    我们可以把一个发送消息的程序称为生产者，把一个接收消息的程序称为消费者。

    在 rabbitmq 的消息队列模型中，生产者将信息发给图中的 **exchange** （交换机）

    我们可以把交换机看作是一个邮局，邮局将生产者给我们的信分发到各个队列。

    **exchange** 可以有多个，它有几种类型：**direct, topic, headers, fanout**

    **exchange** 可以由用户自己建立，但也可以不建立。如果不建立，会使用默认 **exchange**。

    每个建立的队列需要与交换机绑定，绑定的时候可以设置一个路由标志名，称为 **routing key**。

    消息每次传输，都需要传这个 **routing key** 的字段，来判断放到哪个队列。

  * 四种类型的 exchange

    * direct

      直接交换就是只把消息发给和交换机绑定的、并且 **routing key** 完全匹配的队列。一般用作单播，但也可以多播（只要绑定多个队列就可以了）。直接交换多用作消费者之间的任务平衡。

    * topic

      和直接交换类似，主题交换也是发给和交换机绑定的，但 **routing key** 可模糊匹配的队列。（通过 '*' , '#' 等匹配符实现）

      下面是官方文档列出的一些应用场景：

      - 分发与特定地理位置有关的数据，例如销售点
      - 由多个工作人员完成的后台任务处理，每个工作人员都可以处理特定的任务集
      - 涉及分类或标记的新闻更新（例如，仅针对特定运动或团队）

    * fanout

      略过 **routing key** 直接发送给所有绑定的队列。

      下面是一些应用场景

      - 大型多人在线（MMO）游戏可以将其用于排行榜更新或其他全球性事件
      - 体育新闻网站可以使用扇出交换以近乎实时的方式向移动客户端分发 得分 更新
      - 分布式系统可以广播各种状态和配置更新
      - 群组聊天可以使用扇出交换在参与者之间分发消息

    * header 比较少用，这里不讲了。

  * 完整的文档：https://www.rabbitmq.com/tutorials/amqp-concepts.html

#### 3. kafka

* 如何安装？
* 如何使用？